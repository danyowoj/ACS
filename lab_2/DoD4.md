# 1. Запустить любой контейнер с сетевым приложением. Обеспечить сетевой доступ к приложению в контейнере. Для примера можно использовать образ nginx

## Запуск контейнера:

Для запуска контейнера с NGINX используем команду 
```
docker run -d --name my-nginx -p 80:80 nginx
```
Рассмотрим ее по частям:
- `docker run` - команда для запуска контейнера
- `-d` - запускает контейнер в фоновом режиме
- `--name my-nginx` - присваиваем контейнеру имя "my-nginx"
- `-p 80:80` - публикуем порт 80 контейнера на порт 80 хост-машины, обеспечивая сетевой доступ
- `nginx` - указываем образ, который нужно запустить (в данном случае nginx)

После выполнения этой команды контейнер будет запущен в фоновом режиме.

## Сетевой доступ к приложению:
Так как мы опубликовали порт 80 контейнера на порт 80 хост-машины, теперь мы можем получить доступ к NGINX, запущенному в контейнере, через IP-адрес хост-машины. 
Например, если хост-машина имеет IP-адрес _192.168.1.100_, то можно открыть в браузере http://192.168.1.100 и увидеть стандартную страницу NGINX.

## Остановка контейнера:
Для остановки контейнера используем команду 
```
docker stop my-nginx
```
Эта команда остановит контейнер с именем _"my-nginx"_. 
Также можно использовать команду 
```
docker rm my-nginx
``` 
для удаления остановленного контейнера.

# 2. Показать как реагирует контейнер (процесс в контейнере) на команду docker stop - Как производится остановка контейнера системой?
Команда `docker stop` инициирует остановку контейнера, который выполняется в среде Docker, с использованием механизма контроля процессов и изоляции.

## Процесс остановки контейнера
Когда Вы выполняете команду `docker stop`, происходит следующее:
- **Отправка сигнала**: Docker отправляет сигналы процессам, которые работают в контейнере. По умолчанию это сигнал SIGTERM, который сообщает процессу о необходимости завершить свою работу. Обычно контейнер имеет 10 секунд для корректного завершения.

- **Принудительная остановка**: Если процесс не завершился за установленное время, Docker отправляет сигнал SIGKILL, что приводит к принудительной остановке процесса.

- **Управление ресурсами**: После остановки процесса Docker освобождает ресурсы, выделенные для контейнера.

# 3. Продемонстрировать уровни изоляции - PID, ipc, network, users, mount, uts

Контейнеризация позволяет изолировать приложения друг от друга с помощью различных уровней изоляции, предоставляемых ядром.

## PID (Process ID)

Изоляция PID позволяет контейнерам иметь собственное пространство идентификаторов процессов. Это значит, что процессы в контейнере не видят процессы, запущенные на хосте или в других контейнерах.

### Пример:
Запустим два контейнера, чтобы увидеть, как они изолируют свои процессы.
```
# Контейнер 1
docker run -d --name=container1 ubuntu sleep 1000
# Контейнер 2
docker run -d --name=container2 ubuntu sleep 1000
```
Теперь, если мы сохраним PID процесса внутри одного контейнера:
```
docker exec container1 ps aux
```
И сравним его с PID процесса во втором контейнере:
```
docker exec container2 ps aux
```
Мы увидим, что PID процессов внутри каждого контейнера начинается с 1.

## IPC (Inter-Process Communication)

Изоляция IPC предотвращает обмен данными между процессами в разных контейнерах. Каждый контейнер имеет свое пространство для семафоров, очередей сообщений и разделяемой памяти.

### Пример:
Запустим два контейнера и сделаем попытку использовать разделяемую память.
```
docker run -d --name=ipc1 ubuntu bash -c "ipcs -m"
docker run -d --name=ipc2 ubuntu bash -c "ipcs -m"
```
Процесс в одном контейнере не увидит разделяемую память другого контейнера.

## Network (Сеть)

Каждый контейнер может иметь свою собственную сетевую конфигурацию. Контейнеры изолированы друг от друга и от хоста, если не настроены иначе.

### Пример:
Проверим сетевые настройки:
```
docker run -d --name=net1 ubuntu sleep 1000
docker run -d --name=net2 ubuntu sleep 1000
```
```
docker exec net1 ip a
docker exec net2 ip a
```
Каждый контейнер будет иметь свои сетевые интерфейсы, и адреса между ними будут независимы.

## Users (Пользователи)

Контейнеры также имеют собственное пространство пользователей. Это значит, что пользователи в одном контейнере не видят пользователей в другом.

### Пример:
Создайте пользователя в одном контейнере и проверьте его:
```
docker run -d --name=user1 ubuntu bash -c "useradd testuser && tail -f /dev/null"
docker exec user1 id testuser
```
Теперь, если попробуем сделать то же самое в другом контейнере:
```
docker run -d --name=user2 ubuntu bash -c "tail -f /dev/null"
docker exec user2 id testuser
```
Мы увидим, что пользователь testuser не существует.

## Mount (Точки монтирования)

Каждый контейнер имеет свое собственное пространство файловой системы. Например, если мы создадим файл в одном контейнере, он не будет доступен в других.

### Пример:
Создадим файл в одном контейнере:
```
docker run -d --name=mount1 ubuntu bash -c "touch /tmp/myfile && tail -f /dev/null"
docker exec mount1 ls /tmp
```
Теперь попробуем поискать файл в другом контейнере:
```
docker run -d --name=mount2 ubuntu bash -c "ls /tmp"
```
Файл /tmp/myfile не будет найден.

## UTS (UNIX Time Sharing)

Изоляция UTS разрешает каждому контейнеру устанавливать собственные имена хоста и доменов, что позволяет имитировать окружение.

### Пример:
Запустим контейнеры с настройкой имени хоста:
```
docker run -d --name=uts1 --uts=host ubuntu bash -c "hostname my-container-1 && tail -f /dev/null"
docker run -d --name=uts2 --uts=host ubuntu bash -c "hostname my-container-2 && tail -f /dev/null"
```
Теперь, если мы проверим имена хостов в каждом контейнере, мы увидим разные значения.
